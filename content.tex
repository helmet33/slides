%!TEX root = slides.tex

\title{Theory of Algorithms}
\subtitle{}
\author{ian.mcloughlin@gmit.ie}
\date{}


\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Topics}
	\tableofcontents
\end{frame}

\section{Python}


\begin{frame}{About Python}
  \begin{description}
    \item[January 1994] -- Python 1.0.0 released.
    \vspace{0.25cm}
    \item[Guido van Rossum] -- Designer/Author of Python.
    \vspace{0.25cm}
    \item[Current versions] -- 3.5.1 and 2.7.11.
    \vspace{0.25cm}
    \item[Interpreted] -- Python implementation must be present at runtime.
    \vspace{0.25cm}
    \item[Off-side rule] -- Blocks identified by indentation, as opposed to curly braces.
    \vspace{0.25cm} 
    \item[Popularity] -- IEEE Spectrum ranks it as the fourth most popular language (July 2015).
    \vspace{0.25cm}
    \item[Community] -- Python Enhancement Proposals, notably \href{https://www.python.org/dev/peps/pep-0008/}{PEP 8: The Python Style Guide}.
    \vspace{0.25cm} 
  \end{description}
  \citeurl{spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages}
\end{frame}


\begin{frame}{Guido van Rossum}
  \begin{columns}
    \begin{column}{0.2\textwidth}
      \includegraphics[height=2in]{img/guido_van_rossum.jpg}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{itemize}
    		\item Started Python as a hobby.
        \vspace{0.25cm}
    		\item Worked for Google, half-time spent on Python.
        \vspace{0.25cm}
    		\item Now works at Dropbox.
        \vspace{0.25cm}
        \item Benevolent dictator for life (BDFL).
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Conditions}
  \begin{minted}[linenos, frame=lines, framesep=2mm]{python}
x = int(raw_input("Please enter an integer: "))
if x < 0:
  x = 0
  print 'Negative changed to zero'
elif x == 0:
  print 'Zero'
elif x == 1:
  print 'Single'
else:
  print 'More'
  \end{minted}
  \citeurl{docs.python.org/2/tutorial}
\end{frame}

\begin{frame}[fragile]{Loops}
  \begin{minted}[linenos, frame=lines, framesep=2mm]{python}
# A for loop.
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
  print(i, a[i])
  \end{minted}
  \begin{minted}[linenos, frame=lines, framesep=2mm]{python}
# A while loop.
a, b = 0, 1
while b < 1000:
  print(b)
  a, b = b, a+b
  \end{minted}
  \citeurl{docs.python.org/3/tutorial}
\end{frame}

\begin{frame}[fragile]{Functions}
  \begin{minted}[linenos, frame=lines, framesep=2mm]{python}
# write Fibonacci series up to n
def fib(n):   
  """Print a Fibonacci series up to n."""
  a, b = 0, 1
  while a < n:
    print(a)
    a, b = b, a+b
  \end{minted}
  \citeurl{docs.python.org/3/tutorial}
\end{frame}

\begin{frame}{CPython}
  \begin{description}
    \item[Reference implementation] -- Many different Python implementations exist.
    \vspace{0.25cm}
    \item[Version 3] -- Broke backwards compatibility (somewhat).
    \vspace{0.25cm}
    \item[Unladen Swallow] -- Google attempt to fix some Python problems.
    \vspace{0.25cm}
    \item[Modules] -- Lots of great Python modules available.
  \end{description}
  \citeurl{www.python.org}
\end{frame}

\begin{frame}[fragile]{Lists}
	\begin{description}
		\item[Lists] in Python are usually written as comma-separated values between square brackets.
		\item[Types] -- elements of a list don't have to have the same types.
		\item[Slicing] is possible, where we take a sublist of the list.
		\item[Assignment] to slices is possible.
		\item[len()] is a built-in function that returns the length of a list.
		\item[range()] is a built-in function that returns a list of numbers. Note: it returns an \emph{iterator}.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
letters = ['a', 'b', 'c']
letters[1:] = ['c', 'd']
range(10) # [0,1,2,3,4,5,6,7,8,9]
  \end{minted}
  \citeurl{docs.python.org/3/tutorial}
\end{frame}

\begin{frame}[fragile]{Strings}
	\begin{description}
	  \item[Strings] are a lot like lists in Python.
	  \item[Assignment] to slices is not allowed, however.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
words = "This is a sentence."
words[8]         # a
words[5:7]       # is
words[:7]        # This is
words[10:]       # sentence.
words[17:9:-1]   # ecnetnes

len(words)       # 19
"One" + "Two"    # OneTwo
  \end{minted}
	\citeurl{docs.python.org/3/tutorial}
\end{frame}

\begin{frame}[fragile]{Functions}
	\begin{description}
	  \item[def] is the keyword for defining a function.
	  \item[Parameters] can be given defaults, so that they are optional.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
def axn(x, a=1, n=2):
	return a*(x**n)    # ax^n
 
axn(3)       # 9
axn(3, 2)    # 18
axn(3, 2, 3) # 54
axn(3, n=3)  # 27
  \end{minted}
	\citeurl{docs.python.org/3/tutorial}
\end{frame}

\begin{frame}[fragile]{List comprehensions}
	\begin{description}
	  \item[Comprehensions] are quick ways of creating lists from other lists.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
nos = range(5) # [0, 1, 2, 3, 4]
squares = [i*i for i in nos] # [0, 1, 4, 9, 16]
oddsqs = [i*i for i in nos if i % 2 == 1] # [1, 9]
  \end{minted}
	\citeurl{docs.python.org/3/tutorial}
\end{frame}



\begin{frame}[fragile]{map()}
	\begin{description}
	  \item[map()] takes a function and a list.
	  \item[New list] -- it returns a new generator, which is the original list with the function applied to each element.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
map(len, words)
list(map(len, words))
  \end{minted}
	\citeurl{docs.python.org/3/tutorial}
\end{frame}


\begin{frame}[fragile]{Lambda functions}
	\begin{description}
	  \item[lambda] functions are short, inline functions.
	  \item[Nameless] -- lambda functions need not have a name.
	\end{description}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
lambda x: x + n
  \end{minted}
	\citeurl{docs.python.org/3/tutorial}
\end{frame}



\begin{frame}[fragile]{Without generators}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
# Build and return a list
def firstn(n):
    num, nums = 0, []
    while num < n:
        nums.append(num)
        num += 1
    return nums

sum_of_first_n = sum(firstn(1000000))
  \end{minted}
	\citeurl{https://wiki.python.org/moin/Generators}
\end{frame}

\begin{frame}[fragile]{With generators}
	\begin{minted}[linenos, frame=lines, framesep=2mm]{python}
# yields items instead of returning a list
def firstn(n):
    num = 0
    while num < n:
        yield num
        num += 1

sum_of_first_n = sum(firstn(1000000))
  \end{minted}
	\citeurl{https://wiki.python.org/moin/Generators}
\end{frame}


\begin{frame}[fragile]{Permutations}
	\begin{description}
		\item[Permutations] are rearrangements of ordered collections of items.
		\item[Example:] ``abcd'' is a rearrangement of ``bacd''.
	\end{description}
	
	\begin{block}{Abstraction}
		We can consider permutations abstractly.
		For instance, if we have four items to rearrange, we can label the first item 1, the second 2, and so on.
		Then we can represent the various permutations, in terms of the numbers associated with the items.
		The permutations above could be represented by $(1\ 2\ 3\ 4)$ and $(2\ 1\ 3\ 4)$.
		We can see then that when we are considering permutations of $n$ items, it doesn't matter what those items are, we just consider them as numbers.
	\end{block}
\end{frame}


\begin{frame}[fragile]{Counting permutations}
	\begin{block}{With four items, how many distinct permutations are there?}
		Consider having four placeholders where we can place the items:
		\[ \textbf{\fbox{?}} \  \textbf{\fbox{?}} \  \textbf{\fbox{?}} \  \textbf{\fbox{?}} \]
		
		When we place an item in the first box, we have four choices, then we are left with only three choice for the second, two choices for the third, and one choice (i.e.\ not a choice at all) for the last.

	So for there are $4 \times 3 \times 2 \times 1 = 4!$ choices in total.
	\end{block}


\end{frame}

\begin{frame}[fragile]{Counting anagrams}
	\begin{block}{Repitition}
		What happens when we consider two of our items to be the same?
		For instance, what if we are looking for all distinct rearrangements of ``aacd'' as opposed to ``abcd''?
	In that case we need to account for the rearrangements of those items by dividing by the factorial of the number of times each item is repeated: $\frac{4!}{2!}$.
	\end{block}
	
	If more than one item is repeated a number of times we just keep dividing by the factorials of the numbers of repititons.
	The distinct number of rearrangements of ``aaabbcd'' is $\frac{7!}{3!2!}$.

	\begin{block}{Exercise}
		Calculate the number of distinct rearragements of the word ``Mississippi''.
	\end{block}
\end{frame}

\section{Timing Algorithms}

\section{Functional Programming}

\section{Turing Machines}

\section{Complexity Classes}